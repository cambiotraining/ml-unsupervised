{
  "hash": "deb3bce18486fd6d708615a2d35df3f3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: tSNE\n---\n\n::: {.callout-tip}\n#### Learning Objectives\n\n- Bulleted list of learning objectives\n- Why PCA does not work sometimes\n- The intution around the *curse of dimensionality*\n- What is tSNE?\n- How to use tSNE\n:::\n\n\n<!-- TODO: explain curse better -->\n\n## The curse of dimensionality\n\nIn very high-dimensional spaces, almost all the \"volume\" of a dataset lives near its corners, and pairwise Euclidean distances between points tend to concentrate around a single value. \n\n\n## Simplified explanations\n\nThink of each cell as a point in a space where each gene’s activity is its own “axis.” When you have only a few genes (low dimensions), you can tell cells apart by how far apart they sit in that space. But as you add more genes, almost every cell ends up about the same distance from every other cell—so you lose any useful sense of “close” or “far.”\n\n\n\nImagine you're trying to find similar cells in a dataset. As you measure more features (dimensions), it becomes harder to find truly similar cells, even though you have more information.\n\n## Visual Example: Finding Similar Points\n\n### 1 Dimension (1 feature)\n```\nFeature 1: [0]----[1]----[2]----[3]----[4]----[5]\n           A      B      C      D      E      F\n\nPoints A and B are close (distance = 1)\nPoints A and F are far (distance = 5)\n```\n\n### 2 Dimensions (2 features)\n```\nFeature 2: 5 |     F\n           4 |  E\n           3 |     D\n           2 |  C\n           1 |     B\n           0 |A\n             0  1  2  3  4  5  Feature 1\n\nPoints A and B are still close\nPoints A and F are still far\n```\n\n### 3+ Dimensions (3+ features)\n```\nFeature 3: 5 |     F\n           4 |  E\n           3 |     D\n           2 |  C\n           1 |     B\n           0 |A\n             0  1  2  3  4  5  Feature 1\n             \nFeature 4, 5, 6... (more dimensions)\n\nAs dimensions increase:\n- All points become equally distant from each other\n- \"Close\" and \"far\" lose meaning\n- Finding similar cells becomes impossible\n```\n\n## Why This Happens: The \"Empty Space\" Problem\n\n\n2D Circle - most area near the edge:\n\n```\n    ████████\n  ██••••••██\n ██••••••••██\n██••••••••••██\n██••••••••••██\n ██••••••••██\n  ██••••••██\n    ████████\n\n```\n\n::: {.callout-tip}\n**NOTE (IMPORTANT CONCEPT)**: \n\n* ALL volume concentrates at the \"surface\"\nThe interior becomes essentially EMPTY!\n\n* Your data points all end up at the edges, far apart from each other.\n\n\n:::\n<!-- end callout -->\n\n\n## High-dimensions are counter-intuitive\n\nCounter-intuitive things happen in high dimensions. For example, most of the volume is near the edges!\n\n::: {#e48c0047 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-2-output-1.png){width=1001 height=487}\n:::\n:::\n\n\n**Why k-Means fails:**  \nk-Means tries to draw boundaries around groups by asking “Which centroid (group center) is each cell closest to?” In very high–gene spaces, every cell is nearly the same distance from all centroids. Small moves of the centroids don’t change which cells get assigned to them, so k-Means can’t find real groupings.\n\n**Why t-SNE helps:**  \nt-SNE ignores the idea of absolute distance and instead asks, “Which cells are each cell’s few nearest neighbors?” It builds a map that keeps those local neighborhoods intact. In the final 2D picture, cells that were neighbors in the huge gene space stay neighbors on the screen, while cells that weren’t neighbors get pushed apart. This way, you still see meaningful clusters (e.g., cell types) even when dealing with hundreds or thousands of genes.\n\n## TLDR (Simple explanation)\n\nt-SNE (pronounced \"tee-snee\") is a tool that helps us look at complex data by making it easier to see patterns.\n\n### Imagine this:\n- You have a big box of mixed beads. Each bead has many features: color, size, shape, weight, etc.\n- It is hard to see how the beads are similar or different just by looking at all these features at once.\n\n### What t-SNE does:\n- t-SNE takes all those features and creates a simple map (like a 2D picture).\n- In this map, beads that are similar to each other are placed close together.\n- Beads that are very different are placed far apart.\n\n\n## Pictorial explanation of tSNE\n\nHigh-dimensional beads (hard to see groups):\n\n[🔴] [🔵] [🟢] [🟡] [🔴] [🟢] [🔵] [🟡] [🔴] [🟢] [🔵] [🟡]\n\nEach bead has many features (color, size, shape, etc.)\n\n        |\n        v\n\nt-SNE makes a simple 2D map:\n\n[🔴]   [🔴]   [🔴]\n         |      |\n[🔵]   [🔵]   [🔵]\n\n[🟢]   [🟢]   [🟢]\n\n[🟡]   [🟡]   [🟡]\n\nNow, similar beads are grouped together.\n\n\n**In summary:**  \nt-SNE is like a magic tool that turns complicated data into a simple picture, so we can easily see groups and patterns—even if we do not understand the math behind it!\n\n### Why is this useful?\n- It helps us see groups or clusters in our data.\n- We can spot patterns, like which beads are most alike, or if there are outliers.\n- Emphasis on preserving local structure.\n\n## Why t‑SNE Works in High Dimensions\n - Bypasses global distance concentration by focusing on nearest neighbors.\n\n<!-- TODO: intuition behind tSNE \n\nTODO: The explanation of t-SNE could be improved. Currently you refer to it as a \"magic tool\", but the more detailed explanation (in the collapsed box) is very technical and hard to follow. A middle ground with a simple intuitive explanation would help. StatQuest video is excellent for this.\n\n\nTODO: Perplexity is mentioned but not explained, which is worth clarifying.\n\n-->\n\n\n\n::: {.callout-tip collapse=\"true\"}\n\n### The complex explanation\n\nIn very high-dimensional spaces, almost all the “volume” of a dataset lives near its corners, and pairwise Euclidean distances between points tend to concentrate around a single value. As dimension $n$ grows, the volume of an inscribed ball in the hypercube $[-1,1]^n$ shrinks toward zero, and the ratio\n\n$$\n\\frac{\\max d - \\min d}{\\min d}\n$$\n\nfor distances $d$ between random points rapidly approaches zero. Intuitively, “nearest” and “farthest” neighbors become indistinguishable, so any method that relies on global distances (like **k-Means**) loses its ability to meaningfully separate points into clusters.\n\n**k-Means clustering** exemplifies this breakdown: it repeatedly assigns each point to its nearest centroid based on squared-distance comparisons. When all inter-point distances look almost the same, tiny shifts in centroid positions barely affect those assignments, leading to noisy labels and flat optimization landscapes with no clear gradients. In practice, k-Means can “get stuck” or fail to discover any meaningful grouping once dimensions rise into the dozens or hundreds.\n\n**t-SNE** sidesteps these problems by focusing only on **local** similarities rather than global distances. It first converts pairwise distances in the high-dimensional space into a distribution of affinities $p_{ij}$ using Gaussian kernels centered on each point. Then it searches for a low-dimensional embedding whose Student-t affinity distribution $q_{ij}$ best matches $p_{ij}$. By emphasizing the preservation of each point’s nearest neighbors and using a heavy-tailed low-dimensional kernel to push dissimilar points apart, t-SNE highlights local clusters even when global geometry has become uninformative—making it a far more effective visualization and exploratory tool in very high dimensions.\n:::\n<!-- end callout -->\n\n\n## Intuitive explanation of tSNE\n\n[Explanation of tSNE (by StatQuest)](https://www.youtube.com/watch?v=NEaUSP4YerM)\n\n\n## Digging into tSNE\n\n::: {#c14b9036 .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-3-output-1.png){width=1430 height=1134}\n:::\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-3-output-2.png){width=1526 height=575}\n:::\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-3-output-3.png){width=1718 height=1134}\n:::\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-3-output-4.png){width=1526 height=1134}\n:::\n:::\n\n\n---\n\n## tSNE works iteratively\n\ntSNE works iteratively to find similar points and brings them together. This is similar to _clustering_ which we will encounter later.\n\ntSNE gradually moves points to preserve neighborhoods. 🎯 Similar points are pulled together, different cells pushed apart.\n\n<!-- TODO: get animation to work. Needs pip install pillow -->\n\n::: {#a506236c .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-4-output-1.png){width=1072 height=950}\n:::\n:::\n\n\n## Using a t-distribution over points\n\n- **Problem in 2D**: When we compress high‑dimensional data into 2D, many points that were moderately far apart get squashed together. With a Gaussian in 2D, those \"far\" points all look similarly unlikely, which causes **crowding** in the center.\n\n- **t-distribution has heavy tails**: It decreases more slowly than a Gaussian. So points that are moderately far apart in 2D still get some probability—**not zero**.\n\n- **What this achieves**:\n  - **Reduces crowding** in the middle of the plot.\n  - **Spreads clusters out** more naturally.\n  - **Preserves local neighborhoods** (close points stay close) while allowing space between different groups.\n\n- **Intuition**: In high dimensions we can identify close neighbours well. In 2D there isn’t enough room, so everything would pile up. The **heavy tails** of the t‑distribution give extra “elbow room,” keeping clusters distinct and easier to interpret.\n\n::: {#e7a075da .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-5-output-1.png){width=520 height=375}\n:::\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-5-output-2.png){width=509 height=523}\n:::\n:::\n\n\n## Explanation of perplexity\n\ntSNE has an important parameter called _perplexity_.\n\n- **What it is**: Perplexity is like the “number of close friends” each point listens to when arranging the map.\n\n- **How to think about it**: It sets the typical neighborhood size.\n  - **Low perplexity**: each point cares about a small, tight circle.\n  - **High perplexity**: each point _listens_ to more distant neighbors too.\n\n- **If it’s too low**: You may get tiny, fragmented clusters or noisy structure.  \n- **If it’s too high**: Different groups can blur together, losing fine details.  \n- **Good starting range**: 5–50 (try a few values to see what’s most interpretable).\n\n- **Analogy**: Imagine placing cells on a 2D table. Perplexity decides how many nearby \"reference cells\" each one considers when finding its spot—too few and it overfits tiny patterns; too many and it smooths away meaningful differences.\n\n\n\n## What does tSNE look like compared to PCA?\n\n::: {#c52433bc .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-6-output-1.png){width=757 height=566}\n:::\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-6-output-2.png){width=758 height=566}\n:::\n:::\n\n\n## Simple code to perform tSNE (hands-on exercise)\n\n::: {#db1b7e47 .cell execution_count=6}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nfrom sklearn.manifold import TSNE\n\n# Load the Iris dataset\niris = datasets.load_iris()\nX = iris.data            # The features (measurements)\ny = iris.target          # The species labels (0, 1, 2)\n\n# Run t-SNE to reduce the data to 2 dimensions\ntsne = TSNE(n_components=2, random_state=0, perplexity=30)\nX_2d = tsne.fit_transform(X)\n\n# Plot the results, one species at a time\nplt.figure(figsize=(8, 6))\n\n# Setosa (label 0)\nplt.scatter(X_2d[y == 0, 0], X_2d[y == 0, 1], color='red', label='setosa')\n\n# Versicolor (label 1)\nplt.scatter(X_2d[y == 1, 0], X_2d[y == 1, 1], color='green', label='versicolor')\n\n# Virginica (label 2)\nplt.scatter(X_2d[y == 2, 0], X_2d[y == 2, 1], color='blue', label='virginica')\n\nplt.xlabel(\"t-SNE feature 1\")\nplt.ylabel(\"t-SNE feature 2\")\nplt.title(\"t-SNE visualization of the Iris dataset\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-7-output-1.png){width=659 height=523}\n:::\n:::\n\n\n## Exercise: tSNE is stochastic\n\n* Stochasticity: play around with the `random_state` parameter. Does your tSNE plot look different to the person you are seated next to?\n\n* Play around with the `perplexity` parameter (pair up with someone)\n\n* Which value of `perplexity` should you use?\n\n\n\n## Exercise: Building intuition on how to use tSNE\n\n\n* [Pitfalls in using tSNE](https://distill.pub/2016/misread-tsne/)\n\n* Let us read the paper *How to use t-SNE effectively* [@Wattenberg2016].\n\n* Distances are not preserved\n\n* Normal does not always look normal\n\n\n## Key Concept\n\n::: {.callout-tip}\n#### Key Points\n\n- Recall that unsupervised machine learning can help you come up with new hypotheses\n- Vary the perplexity parameter: ideally your patterns or hypotheses should be true even if you change perplexity\n\n:::\n<!--end callout -->\n\n\n## Perplexity pitfalls and things to watch out for\n\n::: {#75db85a7 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](tsne_files/figure-html/cell-8-output-1.png){width=1210 height=1418}\n:::\n:::\n\n\n## PCA vs. tSNE\n\nTODO:\n\n\n\n## Exercise: hands-on practical applying tSNE to another dataset\n\n<!--* XX TODO: FILL IN THE BLANKS EXERCISE\n\n* XX TODO: Load real data from pandas -->\n\n* Load the US Arrests data in Python and perform tSNE on this (pair up with a person)\n\n* How would you evaluate this?\n\n* Vary the `perplexity` parameter\n\n* Some code to help you get started is here:\n\n::: {#c1138d34 .cell execution_count=9}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.manifold import TSNE\n\n# Load the US Arrests data\nurl = \"https://raw.githubusercontent.com/cambiotraining/ml-unsupervised/main/course_files/data/USArrests.csv\"\ndf = pd.read_csv(url, index_col=0)\n\n# Prepare the data for t-SNE\nX = df.values  # Convert to numpy array\n\n# Fill in your code here ..........\n```\n:::\n\n\n\n\n\n\n<!-- TODO: UMAP\n\nbut it might be good if the course went a little further than what’s typically found in most introductory resources. Some additional methods worth at least mentioning are:\n\nMDS (multidimensional scaling)\nPCoA (principal coordinates analysis)\n\n-->\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key Points\n\n- High dimensions make global distances meaningless.\n- Methods that leverage local structure (t‑SNE) can still find patterns.\n- tSNE is stochastic and can be hard to interpret\n- Vary the perplexity parameter (ideally your patterns or hypotheses should be true even if you change perplexity)\n\n:::\n<!--end callout -->\n\n\n## References\n\n[1] [How to Use t-SNE Effectively](https://distill.pub/2016/misread-tsne/)\n\n",
    "supporting": [
      "tsne_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}