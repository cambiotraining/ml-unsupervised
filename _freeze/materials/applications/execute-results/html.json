{
  "hash": "21f96dcc8e31d31c5544a09f5bbdc7d9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Hands-on exercises (Applications of unsupervised machine learning)\n---\n\n::: {.callout-tip}\n#### Learning Objectives\n\n- Understand real-world scenarios where unsupervised learning is applied\n- Identify situations where PCA and other dimensionality reduction techniques may not be effective\n- Practical examples of data that you try unsupervised learning techniques on\n- Learn how to evaluate the performance of unsupervised learning methods\n- Interpret and communicate the results of these models to each other\n:::\n<!-- end callout -->\n\n\n## When PCA may *not* work\n\n### **Non-linear data**\n\n\n- **Non-linearity**: Data that lies on curved surfaces or when data has non-linear relationships.\n- **Single-cell data**: Biological data where cell types form non-linear clusters in high-dimensional space\n\n### **Categorical Features**\n- PCA may work poorly with categorical data unless properly encoded\n- One-hot encoding categorical features can create sparse, high-dimensional data where PCA may not capture meaningful structure\n\n<!--\n### 3. **When Variance Direction ≠ Structure Direction**\n- PCA maximizes variance along principal components, but this doesn't always align with the true underlying structure\n- The lesson shows how PCA on XOR data captures only ~15% variance per component, failing to reveal the true four-cluster structure\n-->\n\n## Alternatives\n\n### **t-SNE** (t-Distributed Stochastic Neighbor Embedding)\n- **Best for**: Non-linear dimensionality reduction and visualization\n- **Key parameter**: Perplexity (try values 5-50)\n- **Use case**: Single-cell data, biological expression data, any non-linear clustering\n\n<!--\n### **Autoencoders**\n- **Best for**: Complex non-linear relationships in deep learning contexts\n- **Use case**: When you need to learn complex representations\n-->\n\n### **Hierarchical Clustering + Heatmaps**\n- **Best for**: Categorical data and understanding relationships between samples\n- **Use case**: When you want to see how samples group together based on multiple features\n\n\n\n### Demonstrating how PCA may fail\n\n* Generate synthetic biological expression data: matrix of 200 samples × 10 genes, where Gene_1 and Gene_2 follow a clustering (four corner clusters) and the remaining genes are just Gaussian noise. You can see from the scatter of Gene_1 vs Gene_2 that the true structure is non-linear and not aligned with any single variance direction: PCA may fail to unfold these clusters into separate principal components.\n\n::: {#8a3daef6 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-2-output-1.png){width=600 height=449}\n:::\n:::\n\n\n* Perform PCA on this data\n\n::: {#c699fbd8 .cell execution_count=2}\n``` {.python .cell-code}\nfrom sklearn.decomposition import PCA\nimport matplotlib.pyplot as plt\n\n# Apply PCA\npca = PCA()\npcs = pca.fit_transform(df) # where df is a dataframe with your data\n\n\n# Scatter plot of the first two principal components\nplt.figure()\nplt.scatter(pcs[:, 0], pcs[:, 1])\nplt.xlabel('PC1')\nplt.ylabel('PC2')\nplt.title('PCA on Synthetic Biological Dataset')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-3-output-1.png){width=587 height=449}\n:::\n:::\n\n\n* Let us try tSNE on this data\n\n::: {#95a860ce .cell execution_count=3}\n``` {.python .cell-code}\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\n\ntsne = TSNE()\ntsne_results = tsne.fit_transform(df)\n\n# plot\nplt.figure()\nplt.scatter(tsne_results[:,0], tsne_results[:,1])\nplt.xlabel('t-SNE component 1')\nplt.ylabel('t-SNE component 2')\nplt.title('t-SNE on Synthetic Biological Dataset')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-4-output-1.png){width=600 height=449}\n:::\n:::\n\n\n* What if we try different values of *perplexity*?\n\n::: {#f1b34b06 .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-5-output-1.png){width=1910 height=470}\n:::\n:::\n\n\n#### What if data has categorical features?\n\n* PCA may not work if you have categorical features\n\nFor example, if you have data that looks like this ....\n\n::: {#344759e2 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\n  species tissue condition\n0   human  liver  diseased\n1   mouse  brain  diseased\n2   human  liver  diseased\n3   human  brain  diseased\n4   mouse  brain   healthy\n```\n:::\n:::\n\n\n::: {#47dd22bf .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-7-output-1.png){width=566 height=470}\n:::\n:::\n\n\n* We can split by disease/healthy, or other features.\n\n::: {#c63cf491 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-8-output-1.png){width=950 height=758}\n:::\n:::\n\n\n* TODO: XX tSNE and color by tissue type\n\n\n* Hierarchical clustering\n\n_Recall_:\n\n**Leaves**: Each leaf at the bottom of the dendrogram represents one sample from your dataset.\n\n**Branches**: The branches connect the samples and groups of samples. The height of the branch represents the distance (dissimilarity) between the clusters being merged.\n\n**Height of Merges**: Taller branches indicate that the clusters being merged are more dissimilar, while shorter branches indicate more similar clusters.\n\n**Clusters**: By drawing a horizontal line across the dendrogram at a certain distance, you can define clusters. All samples below that line that are connected by branches form a cluster.\n\n* In the context of your one-hot encoded categorical data (species, tissue, condition), the dendrogram shows how samples are grouped based on their combinations of these categorical features.\n\n* Samples with the same or very similar combinations of categories will be closer together in the dendrogram and merge at lower distances.\n\n* The structure of the dendrogram reflects the relationships and similarities between the different combinations of species, tissue, and condition present in your synthetic dataset.\n\n::: {#1f6aac76 .cell execution_count=8}\n``` {.python .cell-code}\nfrom scipy.cluster.hierarchy import dendrogram, linkage\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\n# Assume 'encoded_data' exists from the previous one-hot encoding step\nlinked = linkage(y = encoded_data,\n    method = 'ward',\n    metric = 'euclidean',\n    optimal_ordering=True\n    )\n\n# plot dendrogram\nplt.figure()\ndendrogram(linked, \n            orientation='top',\n            distance_sort='descending',\n            show_leaf_counts=True)\nplt.title('Hierarchical Clustering Dendrogram on One-Hot Encoded Categorical Data')\nplt.xlabel('Sample Index')\nplt.ylabel('Distance')\nplt.show()\n\n# or use sns.clustermap()\nsns.clustermap(data=encoded_data,\nmethod = \"ward\",\nmetric = \"euclidean\",\nrow_cluster = True,\ncol_cluster = True,\ncmap = \"vlag\"\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-9-output-1.png){width=623 height=449}\n:::\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-9-output-2.png){width=950 height=951}\n:::\n:::\n\n\n* Heatmaps\n\nHeatmaps are a great way to visualize data and clustering\n\n::: {#fe6019b4 .cell execution_count=9}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Assume 'encoded_df' exists from the previous one-hot encoding step\n\nplt.figure()\nsns.heatmap(encoded_df.T, cmap='viridis', cbar_kws={'label': 'Encoded Value (0 or 1)'}) # Transpose for features on y-axis\n\nplt.title('Heatmap of One-Hot Encoded Categorical Data')\nplt.xlabel('Sample Index')\nplt.ylabel('Encoded Feature')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-10-output-1.png){width=656 height=470}\n:::\n:::\n\n\n## How to evaluate unsupervised learning methods\n\n<!--TODO: XX Potentially NC160 data exercise can live here -->\n\n\n\n## Exercises\n\n* Break up into small groups and work on any one of the following small projects.\n\n### Project using electronic healthcare records data {#sec-exr_title_EHR}\n\n::::: {#ex-title-EHR .callout-exercise}\n\n#### Electronic healthcare records data\n\n{{< level 3 >}}\n\n\nFor this exercise we will be using some data from hospital electronic healthcare records (EHR). No knowledge of biology/healthcare is required for this.\n\n \n:::: {.callout-answer collapse=\"true\"}\n\n#### Project briefing\n\nHere is a brief code snippet to help you load the data and get started.\n\nYou have to follow the following steps:\n\n* Data Loading and Preprocessing: Loading a diabetes dataset and normalizing numerical features.\n\n* Dimensionality Reduction: Applying PCA and t-SNE to reduce the dimensions of the data for visualization and analysis.\n\n* Clustering: Performing K-Means clustering on the reduced data to identify potential patient subgroups.\n\n* Visualization: Visualizing the data in lower dimensions and the identified clusters to gain insights.\n\n::: {.panel-tabset group=\"language\"}\n\n\n## Python\n\n\n\n::: {#fb5d5677 .cell execution_count=11}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\nfrom sklearn.cluster import KMeans\n\n#######################\n# Load diabetes data \n#######################\n\nurl = \"https://raw.githubusercontent.com/cambiotraining/ml-unsupervised/refs/heads/main/course_files/data/diabetes_kaggle.csv\"\ndf = pd.read_csv(url)\n\n######################################\n# Perform data munging and filtering\n######################################\nprint(df.head())\n\n# Normalize numeric columns\nnumeric_cols = df.select_dtypes(include=['float64', 'int64']).columns\nscaler = MinMaxScaler()\ndf_normalized = df.copy() # make a copy\ndf_normalized[numeric_cols] = scaler.fit_transform(df[numeric_cols])\n\n# ALTERNATIVE CODE (repeat for each numeric column)\n# Make a copy so the original DataFrame stays unchanged\n# df_normalized = df.copy()\n\n# Create the scaler\n# scaler = MinMaxScaler()\n\n# Select the 'Glucose' column as a DataFrame (double brackets keep 2D shape)\n# glucose_values = df_normalized[['Glucose']]\n\n# Fit the scaler and transform the values\n# glucose_scaled = scaler.fit_transform(glucose_values)\n\n# Put the scaled values back into the copy\n# df_normalized[['Glucose']] = glucose_scaled\n\n# Filter: Glucose > 0.5 and BMI < 0.3 (normalized values)\nfiltered_df = df_normalized[\n    (df_normalized['Glucose'] > 0.5) &\n    (df_normalized['BMI'] < 0.3)\n]\n\nprint(filtered_df.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Pregnancies  Glucose  BloodPressure  SkinThickness  Insulin   BMI  \\\n0            6      148             72             35        0  33.6   \n1            1       85             66             29        0  26.6   \n2            8      183             64              0        0  23.3   \n3            1       89             66             23       94  28.1   \n4            0      137             40             35      168  43.1   \n\n   DiabetesPedigreeFunction  Age  Outcome  \n0                     0.627   50        1  \n1                     0.351   31        0  \n2                     0.672   32        1  \n3                     0.167   21        0  \n4                     2.288   33        1  \n     Pregnancies   Glucose  BloodPressure  SkinThickness   Insulin       BMI  \\\n9       0.470588  0.628141       0.786885       0.000000  0.000000  0.000000   \n49      0.411765  0.527638       0.000000       0.000000  0.000000  0.000000   \n50      0.058824  0.517588       0.655738       0.111111  0.096927  0.289121   \n145     0.000000  0.512563       0.614754       0.232323  0.000000  0.000000   \n239     0.000000  0.522613       0.622951       0.000000  0.000000  0.274218   \n\n     DiabetesPedigreeFunction       Age  Outcome  \n9                    0.065756  0.550000      1.0  \n49                   0.096926  0.050000      0.0  \n50                   0.176345  0.016667      0.0  \n145                  0.210931  0.000000      0.0  \n239                  0.215201  0.100000      0.0  \n```\n:::\n:::\n\n\n* Visualize the data\n\n::: {#29391e40 .cell execution_count=12}\n``` {.python .cell-code}\n# Histogram\nplt.figure()\nsns.histplot(df_normalized['Glucose'], bins=30)\nplt.title('Distribution of Normalised Glucose')\nplt.xlabel('Normalised Glucose')\nplt.ylabel('Frequency')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-13-output-1.png){width=585 height=449}\n:::\n:::\n\n\n* Now visualize the other variables. Do you notice anything interesting/odd about them? _Hint_: use `sns.histplot()` as shown above or `plt.hist()`.\n\n* Data visualization is a key step in machine learning. Make sure to spend some time visualizing all the variables/features. Discuss the plots in your group.\n\n* Perform PCA\n\n::: {#b8e4a56f .cell execution_count=13}\n``` {.python .cell-code}\nfrom sklearn.decomposition import PCA\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\n# Exclude the target column for PCA\n# We not want to include this because this is something you want to predict.\n# You can use this column in supervised machine learning.\nfeatures = df_normalized.drop(columns=['Outcome'])\n\n# Apply PCA\n# This is where you fill in your code .........\n```\n:::\n\n\n* Fill in the rest of the code with your group members.\n\n* Perform PCA and visualize it. _Hint_: use `plt.scatter()` or `sns.scatterplot()`.\n\n\n\n* Evaluation (how to interpret the PCA plots?)\n\n- _Reminder_: In `plt.scatter`, the `c` parameter controls the marker colour (or colours).\n\n- The `alpha` parameter controls the transparency (opacity) of the markers.\n\n- When passing numbers, you must specify `cmap` (colour map) to control the gradient mapping (otherwise the default colourmap is used)\n\n-  Let us colour by the feature `BMI` now\n\n::: {#c1881fed .cell execution_count=15}\n``` {.python .cell-code}\n# Visualize PCA results colored by BMI\nplt.figure()\nscatter = plt.scatter(pca_df['PC1'], pca_df['PC2'], c=df_normalized['BMI'],\n                     cmap='viridis', alpha=0.7)\nplt.colorbar(scatter, label='BMI (normalized)')\nplt.title('PCA of Diabetes Dataset - Coloured by BMI')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-16-output-1.png){width=571 height=431}\n:::\n:::\n\n\n* Do you see any patterns?\n\n* Now colour by `Pregnancies`\n\n* Try other features: `Glucose`, `BloodPressure`, `SkinThickness`, `Insulin`, `DiabetesPedigreeFunction`, `Age`\n\n* Try spotting any patterns and discuss this in your group\n\n* _Recall_: The primary goal of unsupervised machine learning is to uncover hidden patterns, structures, and relationships within the data. \n\n- This can lead to the generation of new hypotheses about the underlying phenomena, which can then be tested in follow-up studies using statistical methods or through the application of supervised machine learning techniques with labeled data.\n\n- Essentially, unsupervised learning helps us explore the data and formulate questions that can be further investigated.\n\n- However it is never the end of the data science pipeline. It can lead to further investigations.\n\n* Now try tSNE on this data\n\n::: {#b147d774 .cell execution_count=16}\n``` {.python .cell-code}\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\n# Exclude the target column for t-SNE\nfeatures = df_normalized.drop(columns=['Outcome'])\n\n# Apply t-SNE\n# This is where you fill in your code .........\n```\n:::\n\n\n* Perform tSNE on this data\n\n\n\n* Vary the `perplexity` parameter\n\n* Now let us colour the tSNE plot by `BMI`\n\n::: {#e6a25f4b .cell execution_count=18}\n``` {.python .cell-code}\n# Exclude the target column for t-SNE\n# Already done (so commenting out)\n# features_for_tsne = df_normalized.drop(columns=['Outcome', 'Cluster'])\n\n# Create a DataFrame for the t-SNE results\ntsne_df = pd.DataFrame(data=tsne_results, columns=['TSNE1', 'TSNE2'])\n\n# Visualize t-SNE colored by BMI\nplt.figure()\nscatter = plt.scatter(tsne_df['TSNE1'], tsne_df['TSNE2'], c=df_normalized['BMI'],\n                     cmap='viridis', alpha=0.7, s=50)\nplt.colorbar(scatter, label='BMI (normalized)')\nplt.title('t-SNE of Diabetes Dataset - Colored by BMI')\nplt.xlabel('t-SNE Component 1')\nplt.ylabel('t-SNE Component 2')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-19-output-1.png){width=585 height=449}\n:::\n:::\n\n\n* Now colour the tSNE plot by some other feature. Try `Glucose`, `BloodPressure`, `SkinThickness`, `Insulin`, `DiabetesPedigreeFunction`, `Age`\n\n* Do you observe any patterns? Discuss in your group.\n\n* Perform hierarchical clustering on this data\n\n::: {#6363f636 .cell execution_count=19}\n``` {.python .cell-code}\nimport pandas as pd\nfrom scipy.cluster.hierarchy import linkage, dendrogram, fcluster\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Exclude the target column for clustering\nfeatures = df_normalized.drop(columns=['Outcome'])\n\n# Perform hierarchical clustering\n# This is where you fill in your code .........\n```\n:::\n\n\n\n\n* Alternatively you can use `sns.clustermap()`.\n\n_Hint_: Here is some code to get you started.\n\n<!-- \n# Python code that can be used later\n\nehr_col_linkage = linkage(features.T)#, metric=\"ward\")\n\nsns.clustermap(data = features,\nrow_linkage = ehr_row_linkage,\ncol_linkage = ehr_col_linkage,\ncmap = \"vlag\",\nstandard_scale = 0\n)\n-->\n\n::: {.callout-hint collapse=”true”}\n\n::: {#d1276a10 .cell execution_count=21}\n``` {.python .cell-code}\nehr_row_linkage = linkage(features, method=\"ward\")\n\n# plot heatmap using sns.clustermap()\nsns.clustermap(data = features,\nrow_linkage = ehr_row_linkage,\ncmap = \"vlag\",\nstandard_scale = 0\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-22-output-1.png){width=950 height=949}\n:::\n:::\n\n\n:::\n<!-- end callout -->\n\n* Plot heatmaps (heatmaps are a great way to visualize your data!)\n\n::: {#c3bbea7d .cell execution_count=22}\n``` {.python .cell-code}\n# Plot a heatmap of the normalized feature values for all samples\nplt.figure()\nsns.heatmap(features, cmap='viridis', cbar=True)\nplt.title('Heatmap of Normalized Feature Values (All Samples)')\nplt.xlabel('Features')\nplt.ylabel('Sample Index')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-23-output-1.png){width=564 height=610}\n:::\n:::\n\n\n* Perform k-means on this data.\n\n\n\n* Discuss in your group the outcome of this project.\n\n - What are your key findings? \n - Do you think we can find partitions of patients/clusters of patients?\n - What can you do with these partitions?\n\n\n\n## R\n\n\n:::\n\n::::\n\n:::::\n\n \n\n::: {.callout-hint collapse=”true”}\n\nWork in a group!\n\n:::\n\n\n\n\n\n\n### Project using single-cell sequencing data {#sec-exr_singlecell}\n\n::::: {#single-cell .callout-exercise}\n\n#### Single-cell sequencing\n\n{{< level 3 >}}\n\n\nFor this exercise we will be using some single-cell sequencing data. No biological expertise is required for this.\n\n \n:::: {.callout-answer collapse=\"true\"}\n\n#### Exercise\n\nHere is a brief code snippet to help you load the data and get started.\n\nYou have to follow the following steps:\n\n* Data Loading and Preprocessing: Loading a single-cell sequencing dataset and normalizing features.\n\n::: {.panel-tabset group=\"language\"}\n\n\n## Python\n\n* Install packages\n\n::: {#40a238fe .cell execution_count=23}\n``` {.python .cell-code}\n!pip install scanpy scipy matplotlib pandas seaborn\n```\n:::\n\n\n* Load libraries\n\n::: {#7e657bce .cell execution_count=24}\n``` {.python .cell-code}\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\n```\n:::\n\n\n* Load and Preprocess Data: It loads the pbmc3k dataset using scanpy, normalizes the total counts per cell to 10,000, and then applies a log transformation. It then picks out a few \"marker\" genes (genes that may be important for the disease based on our prior knowledge).\n\n* The single cell data is just a table of numbers: the rows are different cells, the columns are genes measured in those cells.\n\n::: {#798e39e4 .cell execution_count=25}\n``` {.python .cell-code}\n# 1. Load data and preprocess\nadata = sc.datasets.pbmc3k()\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\n\n# 2. Subset to marker genes\nmarker_genes = [\n    'CD3D','CD3E','CD4','CD8A',\n    'CD14','LYZ',\n    'MS4A1',\n    'GNLY','NKG7'\n]\n\ngenes = [g for g in marker_genes if g in adata.var_names]\n\nexpr = pd.DataFrame(\n    adata[:, genes].X.toarray(),\n    index=adata.obs_names,\n    columns=genes\n)\n\nprint(expr.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      CD3D      CD3E  CD4      CD8A  CD14       LYZ     MS4A1  \\\nindex                                                                           \nAAACATACAACCAC-1  2.863463  2.225817  0.0  1.635208   0.0  1.635208  0.000000   \nAAACATTGAGCTAC-1  0.000000  0.000000  0.0  0.000000   0.0  1.962726  2.583047   \nAAACATTGATCAGC-1  3.489089  1.994867  0.0  0.000000   0.0  1.994867  0.000000   \nAAACCGTGCTTCCG-1  0.000000  0.000000  0.0  0.000000   0.0  4.521174  0.000000   \nAAACCGTGTATGCG-1  0.000000  0.000000  0.0  0.000000   0.0  0.000000  0.000000   \n\n                      GNLY      NKG7  \nindex                                 \nAAACATACAACCAC-1  0.000000  0.000000  \nAAACATTGAGCTAC-1  0.000000  1.111715  \nAAACATTGATCAGC-1  1.429261  0.000000  \nAAACCGTGCTTCCG-1  0.000000  1.566387  \nAAACCGTGTATGCG-1  3.452557  4.728542  \n```\n:::\n:::\n\n\n* We now have a table of numbers: the rows are cells, and columns are genes measured in those cells.\n\n* Now perform PCA on this data (_Hint_: `expr.values` has all the values. Perform PCA on this.)\n\n\n\n* Now colour this PCA plot by one marker gene `CD3D`. The `CD3D` gene is crucial for immune response. Mutations in this gene can lead to disease. _Hint_: `expr[\"CD3D\"]` will get you all the values of the gene. Use that in the `c = ` option in `plt.scatter()`.\n\n\n\n* Discuss in your group: what do you think the plot means?\n\n* Now try the other marker genes: `CD3E`,`CD4`,`CD8A`, `CD14`, `LYZ`, `MS4A1`, `GNLY`, `NKG7`\n\n* Discuss in your group: what do you think the plot means?\n\n* Now perform tSNE on this. _Hint_: `expr.values` has all the values. Perform tSNE on this.\n\n\n\n* Now colour this PCA plot by one marker gene `CD3D`. _Hint_: `expr[\"CD3D\"]` will get you all the values of the gene. Use that in the `c = ` option in `plt.scatter()`.\n\n\n\n* Discuss in your group: what do you think the plot means?\n\n* Now try the other marker genes: `CD3E`,`CD4`,`CD8A`, `CD14`, `LYZ`, `MS4A1`, `GNLY`, `NKG7`\n\n* Discuss in your group: what do you think the plot means?\n\n* _Reminder_: tSNE is stochastic. \n\n\n* Run tSNE again. Do the clusters remain the same? Can you see the same patterns?\n\n* Run tSNE with a different perplexity value. Do the clusters remain the same?\n\n* Discuss in your group your key findings. What can you say about these clusters?\n\n* Now perform hierarchical clustering on this data.\n\n<!-- https://github.com/neelsoumya/python_machine_learning/blob/main/exercise_singlecell_clustering.ipynb -->\n\n\n\n* Try a few distance functions and linkage functions. \n\n* Plot heatmaps or clustermaps (_Hint_: seaborn `clustermap` does both dendrograms + heatmap in one shot). A representative plot is shown below. Can you try to get a plot similar to this?\n\n* _Hint_: Here is some code to get you started.\n\n::: {.callout-hint collapse=”true”}\n\n```python\nfrom scipy.cluster.hierarchy import linkage\nfrom scipy.spatial.distance import pdist\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# compute linkage\ncell_link = linkage( pdist(expr.T, metric=\"euclidean\"), method=\"ward\" )\ngene_link = linkage( pdist(expr,   metric=\"euclidean\"), method=\"ward\" )\n\n# seaborn clustermap does both dendrograms + heatmap in one shot\n# Fill in the code below .......\nsns.clustermap(.......)\n```\n\n:::\n<!-- end callout -->\n\n\nTODO: XX refine and introduce `sns.clustermap` elsewhere also\n\n::: {#2a879563 .cell execution_count=31}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-32-output-1.png){width=950 height=951}\n:::\n:::\n\n\n* Perform k-means on this data.\n\n* Discuss in your group the outcome of this project.\n\n - What are your key findings? \n - Do you think we can find partitions of cells/clusters of cells?\n - What can you do with these partitions?\n\n\n<!-- \nMore resources on single-cell analysis\n\nhttps://www.sc-best-practices.org/cellular_structure/clustering.html\n-->\n\n\n## R\n\n\n:::\n\n::::\n\n:::::\n\n \n\n::: {.callout-hint collapse=”true”}\n\nWork in a group!\n\n:::\n\n\n\n\n\n\n\n\n### Project using GapMinder data {#sec-gapminder}\n\n::::: {#ex-gapminder .callout-exercise}\n\n#### GapMinder data\n\n{{< level 3 >}}\n\n\nFor this exercise we will be using sociological data.\n\n \n:::: {.callout-answer collapse=\"true\"}\n\n#### Exercise\n\n\nIn this exercise you will explore the _Gapminder_ dataset, focusing on life expectancy, GDP per capita, and population data. You will perform the following steps initially:\n\n1. *Data Loading and Setup*: The gapminder dataset is loaded, and necessary libraries for data manipulation, visualization, and dimensionality reduction are imported.  \n2. *Feature Selection*: The features `lifeExp`, `gdpPercap`, and `pop` are selected for analysis.\n\n\nHere is a brief code snippet to help you load the data and get started.\n\n\n::: {.panel-tabset group=\"language\"}\n\n\n## Python\n\n::: {#5ef3f3ef .cell execution_count=32}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Download Gapminder data\nurl = \"https://raw.githubusercontent.com/resbaz/r-novice-gapminder-files/master/data/gapminder-FiveYearData.csv\"\ngap = pd.read_csv(url)\n\nprint(gap.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       country  year         pop continent  lifeExp   gdpPercap\n0  Afghanistan  1952   8425333.0      Asia   28.801  779.445314\n1  Afghanistan  1957   9240934.0      Asia   30.332  820.853030\n2  Afghanistan  1962  10267083.0      Asia   31.997  853.100710\n3  Afghanistan  1967  11537966.0      Asia   34.020  836.197138\n4  Afghanistan  1972  13079460.0      Asia   36.088  739.981106\n```\n:::\n:::\n\n\n* Subset to countries in Asia and aggregate\n\n::: {#2bace4bf .cell execution_count=33}\n``` {.python .cell-code}\n# Aggregate by country: mean of features for each Asian country\nfeatures = ['lifeExp', 'gdpPercap']\nasia_gap_unique = gap[gap['continent'] == 'Asia'].groupby('country')[features].mean().reset_index()\n\nprint(asia_gap_unique.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       country    lifeExp     gdpPercap\n0  Afghanistan  37.478833    802.674598\n1      Bahrain  65.605667  18077.663945\n2   Bangladesh  49.834083    817.558818\n3     Cambodia  47.902750    675.367824\n4        China  61.785140   1488.307694\n```\n:::\n:::\n\n\n* Visualize the features by using `plt.hist()` or `sns.histplot()`\n\n* Then perform PCA on it. _Hint_: you need to normalize your data also. \n\nDoes your plot look like this?\n\n<!-- \nThe function `pca` in the package `pca` will do it for you if you set `normalize = True`.\n-->\n\n::: {#ad363e05 .cell execution_count=34}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-35-output-1.png){width=600 height=449}\n:::\n:::\n\n\n* Is there anything \"odd\" about this plot? Discuss this in your group.\n\n\n\n* Now label each point on the PCA biplot this by country names\n\n_Hint_: The following code will not work (since \"country\" is categorical). You will have to a bit creative!\n\n```python\nplt.figure()\nplt.scatter(pcs[:,0], pcs[:,1]), c=asia_gap_unique[\"country\"])\nplt.xlabel(\"PC1\")\nplt.ylabel(\"PC2\")\nplt.title(\"Plot of PCA on Gapminder data for Asian countries\")\nplt.show()\n```\n\n::: {.callout-hint collapse=”true”}\n\nHere are some code hints to help you.\n\n::: {#13aeadd6 .cell execution_count=36}\n``` {.python .cell-code}\nplt.figure()\nplt.scatter(pcs[:,0], pcs[:,1])\n\n# add country labels\nfor i, country in enumerate( asia_gap_unique[\"country\"] ):\n    # fill in your code here \n    plt.annotate(.....)\n\nplt.show()\n```\n:::\n\n\nYour plot may look like this:\n\n::: {#619bc2c7 .cell execution_count=37}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-38-output-1.png){width=600 height=411}\n:::\n:::\n\n\n:::\n<!-- end callout -->\n\n* Perform tSNE on this data\n\n::: {#c3a58cee .cell execution_count=38}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-39-output-1.png){width=589 height=449}\n:::\n:::\n\n\n* Do you know notice anything \"odd\"/\"interesting\" about this plot?\n\n* Now add the labels of the countries to this tSNE plot. Here is some _code_ to give you a hint.\n\n\n::: {.callout-hint collapse=”true”}\n\nHere are some code hints to help you.\n\n::: {#55ae8f92 .cell execution_count=39}\n``` {.python .cell-code}\nplt.figure()\nplt.scatter(asia_tsne[:,0], asia_tsne[:,1])\n\n# add country labels\nfor i, country in enumerate( asia_gap_unique[\"country\"] ):\n    # fill in your code here \n    plt.annotate(.....)\n\nplt.show()\n```\n:::\n\n\nYour plot may look like this:\n\n::: {#5549d678 .cell execution_count=40}\n\n::: {.cell-output .cell-output-display}\n![](applications_files/figure-html/cell-41-output-1.png){width=589 height=411}\n:::\n:::\n\n\n:::\n<!-- end callout -->\n\n* Now perform herarchical clustering on this data.\n\nTODO: XX\n\n## R\n\n\n:::\n\n::::\n\n:::::\n\n \n\n::: {.callout-hint collapse=”true”}\n\nWork in a group!\n\n:::\n\n\n\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key Points\n\n- Understand real-world scenarios where unsupervised learning is applied\n- Identify situations where PCA and other dimensionality reduction techniques may not be effective\n- Practical examples of data that you try unsupervised learning techniques on\n:::\n\n",
    "supporting": [
      "applications_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}