{
  "hash": "b1af8f8cdad1fac1553ad2e9cebd70eb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: UMAP (Optional)\n---\n\n::: {.callout-tip}\n#### Learning Objectives\n\n- Brief introduction to UMAP\n- Code to perform UMAP on data\n:::\n\n\n\n# UMAP Intuition\n\n## What is UMAP?\n\n_UMAP_ (Uniform Manifold Approximation and Projection) is another powerful unsupervised machine learning technique that helps visualize high-dimensional data in 2D or 3D. Think of it as a \"smart cartographer\" that creates a map of your complex data, revealing hidden patterns.\n\n## The Core Idea: Preserve Both Local and Global Structure\n\n### The Problem We are Solving\n- Say you have cells with 20,000+ gene measurements\n- You want to see which cells are similar to each other\n- You want to understand both local neighborhoods AND global structure\n- But 20,000 dimensions are impossible to visualize!\n\n### The Solution\nUMAP takes your high-dimensional data and creates a 2D map where:\n- **Similar cells stay close together** (local structure preserved)\n- **Different cells stay far apart** (global structure preserved)\n- **Both local neighborhoods AND global relationships are maintained**\n\n## How UMAP Works: The Intuition\n\n### Step 1: Build a Graph of Relationships\n```\nOriginal Space (20,000+ genes):\nCell A: [Gene1=5, Gene2=10, Gene3=2, ... Gene20000=8]\nCell B: [Gene1=6, Gene2=11, Gene3=3, ... Gene20000=9]\nCell C: [Gene1=50, Gene2=100, Gene3=20, ... Gene20000=80]\n\nUMAP creates a \"friendship network\":\n- A and B are close friends (very similar)\n- A and C are distant acquaintances (very different)\n- B and C are also distant acquaintances\n```\n\n### Step 2: Create a 2D Map\n```\nUMAP creates a 2D layout where:\n- Close friends (A and B) are placed near each other\n- Distant acquaintances (A and C, B and C) are placed far apart\n- The overall \"social network\" structure is preserved\n```\n\n## The \"Manifold\" Concept\n\n### What is a Manifold?\nThink of a manifold like the surface of a balloon:\n- From far away, it looks like a simple sphere\n- Up close, you can see it is actually a 2D surface curved in 3D space\n- Your high-dimensional biological data might be \"curved\" in ways we can't see\n\n### Why \"Uniform\"?\nUMAP assumes your data is spread \"uniformly\" across this curved surface:\n- No empty regions (uniform coverage)\n- No overly crowded regions (uniform density)\n- This helps create a balanced, interpretable map\n\n## UMAP vs t-SNE: Key Differences\n\n### What UMAP Does Better\n\n**Preserves Global Structure**: \n   - t-SNE: Focuses mainly on local neighborhoods\n   - UMAP: Maintains both local AND global relationships\n\n\n<!--\n### Visual Comparison\n```\nt-SNE Result:\n○○○○○  ●●●●●  △△△△△\n○○○○○  ●●●●●  △△△△△\n○○○○○  ●●●●●  △△△△△\n(Good local structure, but distances between clusters are meaningless)\n\nUMAP Result:\n○○○○○     ●●●●●     △△△△△\n○○○○○     ●●●●●     △△△△△\n○○○○○     ●●●●●     △△△△△\n(Both local structure AND meaningful distances between clusters)\n```\n-->\n\n## Key Parameters to Understand\n\n### n_neighbors (Default: 15)\n- Controls how many \"friends\" each cell considers\n- **Low (5-10)**: Focus on very close neighbors, creates many small clusters\n- **High (30-50)**: Consider more distant neighbors, creates fewer, larger clusters\n- **Default (15)**: Usually works well for most datasets\n\n### min_dist (Default: 0.1)\n- Controls how tightly packed points can be in the final map\n- **Low (0.01)**: Points can be very close together (tight clusters)\n- **High (0.5)**: Points spread out more (looser clusters)\n- **Default (0.1)**: Good balance between tightness and readability\n\n### metric (Default: 'euclidean')\n- How to measure distances between cells\n- **'euclidean'**: Standard geometric distance (good for most data)\n- **'cosine'**: Angle-based distance (good for normalized data)\n- **'manhattan'**: City-block distance (good for sparse data)\n\n<!--\n## Real Biological Examples\n\n### Single-Cell RNA Sequencing\n```\nOriginal data: 10,000 cells × 20,000 genes = 200 million data points\n\nUMAP reveals:\n- Clear cell type clusters (neurons, glia, immune cells)\n- Developmental trajectories (cells transitioning between types)\n- Meaningful distances between clusters (immune cells are far from neurons)\n- Sub-clusters within major cell types (different neuron subtypes)\n```\n\n### Protein Expression Data\n```\nOriginal data: 1,000 cells × 50 proteins = 50,000 data points\n\nUMAP reveals:\n- Protein co-expression patterns\n- Cell state transitions\n- Treatment response groups\n- Quality control issues (outliers, batch effects)\n```\n\n## Common Patterns in UMAP Plots\n\n### Clear Clusters with Meaningful Distances\n```\n○○○○○     ●●●●●     △△△△△\n○○○○○     ●●●●●     △△△△△\n○○○○○     ●●●●●     △△△△△\n\nThis suggests: 3 distinct cell types with meaningful relationships\n- Distance between ○ and ● clusters tells you how different they are\n- Distance between ● and △ clusters tells you how different they are\n```\n\n### Developmental Trajectories\n```\n○○●●△△\n○○●●△△\n○○●●△△\n\nThis suggests: Cells transitioning from ○ → ● → △\n- You can trace the developmental path\n- Intermediate cells show mixed characteristics\n```\n\n### Hierarchical Structure\n```\n    ○○○○○\n   ○○○○○○○\n  ○○○○○○○○○\n     ●●●●●\n    ●●●●●●●\n   ●●●●●●●●●\n      △△△△△\n     △△△△△△△\n    △△△△△△△△△\n\nThis suggests: Major cell types (○, ●, △) with subtypes within each\n```\n\n-->\n\n<!--\n## When to Use UMAP\n\n### Excellent for:\n- **Exploratory data analysis**: \"What's the overall structure of my data?\"\n- **Cell type identification**: \"How many different cell types do I have?\"\n- **Trajectory analysis**: \"How do cells transition between states?\"\n- **Quality control**: \"Are there any weird outliers or batch effects?\"\n- **Comparative analysis**: \"How do different conditions compare?\"\n\n### Good for:\n- **Feature selection**: \"Which genes/proteins are most important?\"\n- **Clustering validation**: \"Do my clusters make sense?\"\n- **Hypothesis generation**: \"These cells look similar, maybe they're related?\"\n\n### Not ideal for:\n- **Exact quantitative comparisons**: \"How similar are these cells exactly?\"\n- **Very small datasets**: \"I only have 50 cells\"\n- **Highly noisy data**: \"My data is very messy\"\n\n-->\n\n\n## UMAP vs Other Methods\n\n### UMAP vs PCA\n- **PCA**: Linear method, preserves variance, good for linear relationships\n- **UMAP**: Non-linear method, preserves local structure, good for complex relationships\n\n### UMAP vs t-SNE\n- **t-SNE**: Great for local structure, slower, harder to interpret distances\n- **UMAP**: Good for both local and global structure, faster, more interpretable\n\n<!--\n### UMAP vs UMAP (Different Parameters)\n- **Low n_neighbors**: More local detail, more clusters\n- **High n_neighbors**: More global view, fewer clusters\n- **Low min_dist**: Tighter clusters, harder to see individual points\n- **High min_dist**: Looser clusters, easier to see individual points\n-->\n\n## Practical Tips\n\n### 1. Start with Default Parameters\n- UMAP's defaults work well for most biological data\n- Don't over-optimize parameters initially\n\n### 2. Try Different n_neighbors Values\n- **5-10**: If you want to see fine-grained subpopulations\n- **15-30**: For general exploration (recommended)\n- **50+**: If you want to see only major cell types\n\n### 3. Adjust min_dist for Readability\n- **0.01-0.05**: If points are too spread out\n- **0.1-0.3**: Default range (recommended)\n- **0.5+**: If clusters are too tight\n\n### 4. Use Multiple Runs\n- UMAP has some randomness\n- Run multiple times to ensure results are consistent\n- Use `random_state` parameter for reproducible results\n\n### 5. Validate with Biology\n- Always check if UMAP results make biological sense\n- Compare with known cell type markers\n- Look for expected developmental trajectories\n\n## Summary\n\nUMAP is like a smart cartographer who:\n1. **Studies your high-dimensional data** (20,000+ genes/proteins)\n2. **Identifies both local neighborhoods AND global relationships**\n3. **Creates a beautiful 2D map** that preserves both types of structure\n4. **Reveals hidden patterns** you couldn't see before\n\nThe key insight: **UMAP preserves both local and global structure** - cells that are similar stay close together, while the distances between different cell types remain meaningful.\n\nThis makes UMAP perfect for biologists who want to understand the complete structure of their complex, high-dimensional data - from individual cell relationships to overall tissue organization!\n\n<!--\n## Next Steps\n\n1. **Try the simple UMAP code** with your own data\n2. **Experiment with different parameters** to see how they affect the results\n3. **Compare UMAP with t-SNE** on the same dataset\n4. **Validate results** with known biological markers\n5. **Use UMAP for hypothesis generation** and further experiments\n-->\n\n_Remember_: UMAP is a tool for exploration and visualization, not a replacement for careful analysis!\n\n\n## Hands-on with UMAP\n\nThe way to use _UMAP_ is similar to how we did tSNE.\n\n::: {#3bb5ae27 .cell execution_count=1}\n``` {.python .cell-code}\n!pip install umap-learn\n```\n:::\n\n\n::: {#c62ef604 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom sklearn import datasets\nfrom sklearn.preprocessing import StandardScaler\nimport umap\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set(style=\"whitegrid\")  # nice simple plots\n\niris = datasets.load_iris()\nX_iris = iris.data           # 150 samples, 4 features (sepal/petal lengths/widths)\ny_iris = iris.target         # species labels (0,1,2)\nlabels_iris = iris.target_names\n\n# create a data frame for easier viewing\ndf_iris_simple = pd.DataFrame(X_iris, columns = iris.feature_names)\n\ndf_iris_simple['species'] = iris.target\ndf_iris_simple['species_name'] = df_iris_simple['species'].map( {0:'setosa', 1:'versicolor', 2:'virginica'} )\n\n# display basic information\nprint(df_iris_simple.head)\n\n# scatter plots\nplt.figure()\nplt.scatter(X_iris[:,0], X_iris[:,1], c = iris.target, cmap='viridis')\nplt.xlabel(iris.feature_names[0])\nplt.ylabel(iris.feature_names[1])\nplt.title('Sepal length vs. Sepal width')\nplt.colorbar(label='species')\nplt.show()\n\n# Standardize features \nscaler = StandardScaler()\nX_iris_scaled = scaler.fit_transform(X_iris)\n\n# Run UMAP\numap_model = umap.UMAP(n_neighbors=15, min_dist=0.1, n_components=2, random_state=42)\nembedding_iris = umap_model.fit_transform(X_iris_scaled)\n\n# Put into DataFrame for plotting\ndf_iris = pd.DataFrame({\n    \"UMAP1\": embedding_iris[:, 0],\n    \"UMAP2\": embedding_iris[:, 1],\n    \"species\": [labels_iris[i] for i in y_iris]\n})\n\nplt.figure()\nsns.scatterplot(data=df_iris, x=\"UMAP1\", y=\"UMAP2\", hue=\"species\", s=60)\nplt.title(\"UMAP on Iris data\")\nplt.legend(loc=\"best\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<bound method NDFrame.head of      sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)  \\\n0                  5.1               3.5                1.4               0.2   \n1                  4.9               3.0                1.4               0.2   \n2                  4.7               3.2                1.3               0.2   \n3                  4.6               3.1                1.5               0.2   \n4                  5.0               3.6                1.4               0.2   \n..                 ...               ...                ...               ...   \n145                6.7               3.0                5.2               2.3   \n146                6.3               2.5                5.0               1.9   \n147                6.5               3.0                5.2               2.0   \n148                6.2               3.4                5.4               2.3   \n149                5.9               3.0                5.1               1.8   \n\n     species species_name  \n0          0       setosa  \n1          0       setosa  \n2          0       setosa  \n3          0       setosa  \n4          0       setosa  \n..       ...          ...  \n145        2    virginica  \n146        2    virginica  \n147        2    virginica  \n148        2    virginica  \n149        2    virginica  \n\n[150 rows x 6 columns]>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](umap_files/figure-html/cell-3-output-2.png){width=594 height=455}\n:::\n\n::: {.cell-output .cell-output-display}\n![](umap_files/figure-html/cell-3-output-3.png){width=593 height=455}\n:::\n:::\n\n\n* Quick tips:\n\n- `n_neighbors` (default ~15): how many neighbors UMAP uses to learn local structure.\n\n  Smaller => captures very local structure (more fragmentation), larger => more global structure.\n\n- `min_dist` (default ~0.1): how tightly points are packed in the low-dimensional space.\n  Smaller => tighter clusters; larger => more spread out.\n\n- Always standardize or log-transform expression data before UMAP (depending on data type).\n\n- Try different random_state values or parameters to see what changes.\n\n\n* Exercises for learners:\n\n1. Change `n_neighbors` to 5 and then to 50 and observe how the plot changes.\n\n2. Change `min_dist` to 0.01 and 0.8 and observe clustering differences.\n\n3. Replace synthetic data with a small real gene-expression matrix and try the pipeline:\n   counts -> log1p -> StandardScaler -> UMAP.\n\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key Points\n\n- A brief introduction to UMAP\n:::\n\n",
    "supporting": [
      "umap_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}