---
title: Hands-on exercises (Applications of unsupervised machine learning)
---

::: {.callout-tip}
#### Learning Objectives

- Understand real-world scenarios where unsupervised learning is applied
- Identify situations where PCA and other dimensionality reduction techniques may not be effective
- Practical examples of data that you try unsupervised learning techniques on
- Learn how to evaluate the performance of unsupervised learning methods
- Interpret and communicate the results of these models to each other
:::
<!-- end callout -->


## When PCA does *not* work

* When *not* to apply PCA or when PCA does *not* work

### Key Takeaways: When PCA Fails

### 1. **Non-linear Data Structures**
- **Non-linearity**: Data that lies on curved surfaces or when data has non-linear relationships.
- **Single-cell data**: Biological data where cell types form non-linear clusters in high-dimensional space

### 2. **Categorical Features**
- PCA works poorly with categorical data unless properly encoded
- One-hot encoding categorical features can create sparse, high-dimensional data where PCA may not capture meaningful structure

<!--
### 3. **When Variance Direction ≠ Structure Direction**
- PCA maximizes variance along principal components, but this doesn't always align with the true underlying structure
- The lesson shows how PCA on XOR data captures only ~15% variance per component, failing to reveal the true four-cluster structure
-->

## Better Alternatives

### **t-SNE** (t-Distributed Stochastic Neighbor Embedding)
- **Best for**: Non-linear dimensionality reduction and visualization
- **Key parameter**: Perplexity (try values 5-50)
- **Use case**: Single-cell data, biological expression data, any non-linear clustering

<!--
### **Autoencoders**
- **Best for**: Complex non-linear relationships in deep learning contexts
- **Use case**: When you need to learn complex representations
-->

### **Hierarchical Clustering + Heatmaps**
- **Best for**: Categorical data and understanding relationships between samples
- **Use case**: When you want to see how samples group together based on multiple features



### Code to demonstrate how PCA can fail

* Generate synthetic biological expression data: matrix of 200 samples × 10 genes, where Gene_1 and Gene_2 follow a clustering (four corner clusters) and the remaining genes are just Gaussian noise. You can see from the scatter of Gene_1 vs Gene_2 that the true structure is non-linear and not aligned with any single variance direction: PCA would fail to unfold these clusters into separate principal components.

```{python ch4-pca-not-work}
#| warning: false
#| echo: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

# Parameters
n_samples = 200
n_genes = 10

# Generate XOR structure for genes 1 and 2
gene1 = np.random.choice([0, 1], size=n_samples)
gene2 = np.random.choice([0,1],  size=n_samples)
# For continuous spread, add small noise
gene1 = gene1 + 0.1 * np.random.randn(n_samples)
gene2 = gene2 + 0.1 * np.random.randn(n_samples)

# Generate remaining genes as random noise
other_genes = np.random.randn(n_samples, n_genes - 2)

# Combine into a DataFrame
data = np.hstack([gene1.reshape(-1,1), gene2.reshape(-1,1), other_genes])
genes = [f'Gene_{i+1}' for i in range(n_genes)]
df = pd.DataFrame(data, columns=genes)

# Scatter plot for Gene_1 vs Gene_2 to visualize the non-linear structure
plt.figure()
plt.scatter(df['Gene_1'], df['Gene_2'])
plt.title('Scatter of Gene_1 vs Gene_2')
plt.xlabel('Gene_1 expression')
plt.ylabel('Gene_2 expression')
plt.show()
```

* Perform PCA on this data

```{python ch4-pca-synthetic_data}
#| warning: false

from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

# Apply PCA
pca = PCA()
pcs = pca.fit_transform(df)


# Scatter plot of the first two principal components
plt.figure()
plt.scatter(pcs[:, 0], pcs[:, 1])
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA on Synthetic Biological Dataset')
plt.show()
```

* Let us try tSNE on this data

```{python ch4-tsne-synthetic-data}
#| warning: false

from sklearn.manifold import TSNE
import matplotlib.pyplot as plt

tsne = TSNE()
tsne_results = tsne.fit_transform(df)

# plot
plt.figure()
plt.scatter(tsne_results[:,0], tsne_results[:,1])
plt.xlabel('t-SNE component 1')
plt.ylabel('t-SNE component 2')
plt.title('t-SNE on Synthetic Biological Dataset')
plt.show()

```

* What if we try different values of *perplexity*?

```{python ch4-tnse-perplexity-vary-synthetic-data}
#| warning: false
#| echo: false

from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
import numpy as np

# Convert DataFrame to numpy array
data = df.values

# Define different perplexity values to explore
perplexities = [2, 5, 30, 50, 100] # Exploring values between 2 and 100

plt.figure(figsize=(20,5)) # Adjust figure size for more subplots

for i, perplexity in enumerate(perplexities):
    tsne = TSNE(n_components=2, random_state=42, perplexity=perplexity)
    tsne_results = tsne.fit_transform(data)

    # Create a subplot for each perplexity value
    plt.subplot(1, len(perplexities), i + 1)
    plt.scatter(tsne_results[:, 0], tsne_results[:, 1])
    plt.title(f't-SNE (Perplexity={perplexity})')
    plt.xlabel('t-SNE component 1')
    plt.ylabel('t-SNE component 2')

plt.tight_layout() # Adjust layout to prevent overlap
plt.show()
```


#### What if data has categorical features?

* PCA may not work if you have categorical features

```{python ch4-pca-categorical-generate}
#| warning: false

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

# Generate synthetic data with categorical features
np.random.seed(42)
n_samples = 200

# Categorical features
species = np.random.choice(['mouse', 'rat', 'human'], size=n_samples)
tissue = np.random.choice(['liver', 'brain', 'heart'], size=n_samples)
condition = np.random.choice(['healthy', 'diseased'], size=n_samples)

# Create DataFrame
df_cat = pd.DataFrame({
    'species': species,
    'tissue': tissue,
    'condition': condition
})

print(df_cat.head())

# One-hot encode the categorical features
encoder = OneHotEncoder(sparse_output=False)
encoded_data = encoder.fit_transform(df_cat)

# Apply PCA
pca = PCA(n_components=2)
pcs = pca.fit_transform(encoded_data)

# Plot PCA result
plt.figure(figsize=(6,5))
plt.scatter(pcs[:, 0], pcs[:, 1], alpha=0.7)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA on One-Hot Encoded Categorical Data')
plt.grid(True)
plt.tight_layout()
plt.show()

# Show the one-hot encoded feature names
encoded_feature_names = encoder.get_feature_names_out(df_cat.columns)
encoded_df = pd.DataFrame(encoded_data, columns=encoded_feature_names)

```

* We can split by disease/healthy, etc.

```{python ch4-pca-color-by-type}
#| warning: false
#| echo: false

# Plot PCA result
plt.figure(figsize=(10, 8))

# Create subplot for PCA
plt.subplot(2, 2, 1)
plt.scatter(pcs[:, 0], pcs[:, 1], alpha=0.7)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA on One-Hot Encoded Categorical Data')
plt.grid(True)

# Create subplot showing PCA with colors based on species
plt.subplot(2, 2, 2)
colors = {'mouse': 'red', 'rat': 'blue', 'human': 'green'}
for sp in ['mouse', 'rat', 'human']:
    mask = df_cat['species'] == sp
    plt.scatter(pcs[mask, 0], pcs[mask, 1], c=colors[sp], label=sp, alpha=0.7)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA Colored by Species')
plt.legend()
plt.grid(True)

# Create subplot showing PCA with colors based on tissue
plt.subplot(2, 2, 3)
colors_tissue = {'liver': 'orange', 'brain': 'purple', 'heart': 'brown'}
for tissue_type in ['liver', 'brain', 'heart']:
    mask = df_cat['tissue'] == tissue_type
    plt.scatter(pcs[mask, 0], pcs[mask, 1], c=colors_tissue[tissue_type], label=tissue_type, alpha=0.7)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA Colored by Tissue')
plt.legend()
plt.grid(True)

# Create subplot showing PCA with colors based on condition
plt.subplot(2, 2, 4)
colors_condition = {'healthy': 'green', 'diseased': 'red'}
for cond in ['healthy', 'diseased']:
    mask = df_cat['condition'] == cond
    plt.scatter(pcs[mask, 0], pcs[mask, 1], c=colors_condition[cond], label=cond, alpha=0.7)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.title('PCA Colored by Condition')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
```

* TODO: XX tSNE and color by tissue type


* Hierarchical clustering

**Leaves**: Each leaf at the bottom of the dendrogram represents one sample from your dataset.

**Branches**: The branches connect the samples and groups of samples. The height of the branch represents the distance (dissimilarity) between the clusters being merged.

**Height of Merges**: Taller branches indicate that the clusters being merged are more dissimilar, while shorter branches indicate more similar clusters.

**Clusters**: By drawing a horizontal line across the dendrogram at a certain distance, you can define clusters. All samples below that line that are connected by branches form a cluster.

* In the context of your one-hot encoded categorical data (species, tissue, condition), the dendrogram shows how samples are grouped based on their combinations of these categorical features.

* Samples with the same or very similar combinations of categories will be closer together in the dendrogram and merge at lower distances.

* The structure of the dendrogram reflects the relationships and similarities between the different combinations of species, tissue, and condition present in your synthetic dataset.

```{python ch4-hclust-cat-data}
#| warning: false

from scipy.cluster.hierarchy import dendrogram, linkage
from matplotlib import pyplot as plt

# Assume 'encoded_data' exists from the previous one-hot encoding step
linked = linkage(encoded_data, 'ward')

# plot dendrogram
plt.figure()
dendrogram(linked, 
            orientation='top',
            distance_sort='descending',
            show_leaf_counts=True)
plt.title('Hierarchical Clustering Dendrogram on One-Hot Encoded Categorical Data')
plt.xlabel('Sample Index')
plt.ylabel('Distance')
plt.show()
```

* Heatmaps

Heatmaps are a great way to visualize data and clustering

```{python ch4-heatmaps}
#| warning: false

import seaborn as sns
import matplotlib.pyplot as plt

# Assume 'encoded_df' exists from the previous one-hot encoding step

plt.figure(figsize=(12, 8)) # Adjust figure size as needed
sns.heatmap(encoded_df.T, cmap='viridis', cbar_kws={'label': 'Encoded Value (0 or 1)'}) 

# Transpose for features on y-axis
plt.title('Heatmap of One-Hot Encoded Categorical Data')
plt.xlabel('Sample Index')
plt.ylabel('Encoded Feature')
plt.tight_layout()
plt.show()
```

## How to evaluate unsupervised learning methods

TODO: XX Potentially NC160 data exercise can live here



## Exercises

* Break up into small groups and work on any one of the following small projects.

### Project using electronic healthcare records data {#sec-exr_title_EHR}

::::: {#ex-title-EHR .callout-exercise}

#### Electronic healthcare records data

{{< level 3 >}}


For this exercise we will be using some data from hospital electronic healthcare records (EHR). No knowledge of biology/healthcare is required for this.

 
:::: {.callout-answer collapse="true"}

#### Project briefing

Here is a brief code snippet to help you load the data and get started.

You have to follow the following steps:

* Data Loading and Preprocessing: Loading a diabetes dataset and normalizing numerical features.

* Dimensionality Reduction: Applying PCA and t-SNE to reduce the dimensions of the data for visualization and analysis.

* Clustering: Performing K-Means clustering on the reduced data to identify potential patient subgroups.

* Visualization: Visualizing the data in lower dimensions and the identified clusters to gain insights.

::: {.panel-tabset group="language"}


## Python

```{python ch4-exercise-EHR-install}
#| warning: false
#| output: false

!pip install pandas scikit-learn seaborn matplotlib openml

```

```{python ch4-exercise-EHR-loaddata}
#| warning: false

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.cluster import KMeans
import openml

#######################
# Load diabetes data 
#######################

url = "https://raw.githubusercontent.com/neelsoumya/python_machine_learning/main/data/diabetes_kaggle.csv"
df = pd.read_csv(url)

######################################
# Perform data munging and filtering
######################################

# Normalize numeric columns
numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns
scaler = MinMaxScaler()
df_normalized = df.copy()
df_normalized[numeric_cols] = scaler.fit_transform(df[numeric_cols])

# Filter: Glucose > 0.5 and BMI < 0.3 (normalized values)
filtered_df = df_normalized[
    (df_normalized['Glucose'] > 0.5) &
    (df_normalized['BMI'] < 0.3)
]

print(filtered_df.head())
```

* Visualize the data

```{python ch4-ehr-viz}
#| warning: false

# Histogram
plt.figure()
sns.histplot(df_normalized['Glucose'], bins=30)
plt.title('Distribution of Normalized Glucose')
plt.xlabel('Normalized Glucose')
plt.ylabel('Frequency')
plt.show()
```

* Now visualize the other variables? Do you notice anything interesting/weird about them?

* Perform PCA

```{python ch4-ehr-pca}
#| warning: false

from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Exclude the target column for PCA
features = df_normalized.drop(columns=['Outcome'])

# Apply PCA
# This is where you fill in your code .........

```

* Fill in the rest of the code with your group members\

* Perform PCA and visualize it

```{python ch4-ehr-pca-hidefromstudents}
#| warning: false
#| echo: false
#| output: false

pca = PCA(n_components=2)
principal_components = pca.fit_transform(features)

# Create a DataFrame for the principal components
pca_df = pd.DataFrame(data=principal_components, columns=['PC1', 'PC2'])
pca_df['Outcome'] = df_normalized['Outcome'].values

# Visualize
plt.figure()
sns.scatterplot(x='PC1', y='PC2', hue='Outcome', data=pca_df, palette='Set1', alpha=0.7)
plt.title('PCA of Diabetes Dataset')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.legend(title='Outcome')
plt.show()
```

* Evaluation (how to interpret the PCA plots?)

- In `plt.scatter`, the `c` parameter controls the marker colour (or colours).

- the `alpha` parameter controls the transparency (opacity) of the markers.

-  When passing numbers, you must specify `cmap` (colour map) to control the gradient mapping (otherwise the default colourmap is used)

-  Let us colour by `BMI` now

```{python ch4-ehr-interpret-pca}
#| warning: false

# Visualize PCA results colored by BMI
plt.figure()
scatter = plt.scatter(pca_df['PC1'], pca_df['PC2'], c=df_normalized['BMI'],
                     cmap='viridis', alpha=0.7)
plt.colorbar(scatter, label='BMI (normalized)')
plt.title('PCA of Diabetes Dataset - Coloured by BMI')
plt.show()
```

* Do you see any patterns?

* Now colour by `Pregnancies`

* Try other features: `Glucose`, `BloodPressure`, `SkinThickness`, `Insulin`, `DiabetesPedigreeFunction`, `Age`

* Try spotting any patterns and discuss this in your group

* _RECALL_: The primary goal is to uncover hidden patterns, structures, and relationships within the data. This can lead to:

- The generation of new hypotheses about the underlying phenomena, which can then be tested in follow-up studies using statistical methods or through the application of supervised machine learning techniques with labeled data.

- Essentially, unsupervised learning helps us explore the data and formulate questions that can be further investigated.

- However it is never the end of the data science pipeline but leads to more targetted investigations. 

* Now try tSNE on this data

```{python ch4-ehr-tsne}
#| warning: false

from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Exclude the target column for t-SNE
features = df_normalized.drop(columns=['Outcome'])

# Apply t-SNE
# This is where you fill in your code .........
```

* Perform tSNE on this data

```{python ch4-ehrdata-tsne-hidden}
#| warning: false
#| echo: false
#| output: false

# Apply t-SNE
tsne = TSNE(n_components=2, random_state=42, perplexity=30)
tsne_results = tsne.fit_transform(features)

# Create a DataFrame for the t-SNE results
tsne_df = pd.DataFrame(data=tsne_results, columns=['TSNE1', 'TSNE2'])
tsne_df['Outcome'] = df_normalized['Outcome'].values

# Visualize
plt.figure()
sns.scatterplot(x='TSNE1', y='TSNE2', hue='Outcome', data=tsne_df, palette='Set1', alpha=0.7)
plt.title('t-SNE of Diabetes Dataset')
plt.xlabel('t-SNE Component 1')
plt.ylabel('t-SNE Component 2')
plt.legend(title='Outcome')
plt.show()
```

* Vary the `perplexity` parameter

* Now let us color the tSNE plot by `BMI`

```{python ch4-ehr-data-tsne-color}
#| warning: false

# Exclude the target column for t-SNE
# Already done (so commenting out)
# features_for_tsne = df_normalized.drop(columns=['Outcome', 'Cluster'])

# Apply t-SNE
tsne = TSNE(n_components=2, random_state=42, perplexity=30)
tsne_results = tsne.fit_transform(features)

# Create a DataFrame for the t-SNE results
tsne_df = pd.DataFrame(data=tsne_results, columns=['TSNE1', 'TSNE2'])
#tsne_df['Outcome'] = df_normalized['Outcome'].values
#tsne_df['Cluster'] = df_normalized['Cluster'].values

# Visualize t-SNE colored by BMI
plt.figure(figsize=(10, 8))
scatter = plt.scatter(tsne_df['TSNE1'], tsne_df['TSNE2'], c=df_normalized['BMI'],
                     cmap='viridis', alpha=0.7, s=50)
plt.colorbar(scatter, label='BMI (normalized)')
plt.title('t-SNE of Diabetes Dataset - Colored by BMI')
plt.xlabel('t-SNE Component 1')
plt.ylabel('t-SNE Component 2')
plt.show()
```

* Now colour the tSNE plot by some other feature. Try `Glucose`, `BloodPressure`, `SkinThickness`, `Insulin`, `DiabetesPedigreeFunction`, `Age`

* Do you observe any patterns? Discuss in your group.

* Perform hierarchical clustering on this data

```{python ch4-ehr-hclust-1}
#| warning: false

import pandas as pd
from scipy.cluster.hierarchy import linkage, dendrogram, fcluster
import matplotlib.pyplot as plt
import seaborn as sns

# Exclude the target column for clustering
features = df_normalized.drop(columns=['Outcome'])

# Perform hierarchical clustering
# This is where you fill in your code .........
```

```{python ch4-hclust-ehr-notdisplay}
#| warning: false
#| echo: false
#| output: false 

Z = linkage(features, method='ward')

# Plot dendrogram
plt.figure()
dendrogram(Z, truncate_mode='level', p=5)
plt.title('Hierarchical Clustering Dendrogram')
plt.xlabel('Sample Index')
plt.ylabel('Distance')
plt.show()
```

* Plot heatmaps (heatmaps are a great way to visualize your data)

```{python ch4-ehr-heatmaps-show}
#| warning: false

# Plot a heatmap of the normalized feature values for all samples
plt.figure()
sns.heatmap(features, cmap='viridis', cbar=True)
plt.title('Heatmap of Normalized Feature Values (All Samples)')
plt.xlabel('Features')
plt.ylabel('Sample Index')
plt.show()
```

* Perform k-means on this data.



* Discuss in your group the outcome of this project.

 - What are your key findings? 
 - Do you think we can find partitions of patients/clusters of patients?
 - What can you do with these partitions?



## R


:::

::::

:::::

 

::: {.callout-hint collapse=”true”}

Work in a group!

:::






### Single-cell sequencing data {#sec-exr_singlecell}

::::: {#single-cell .callout-exercise}

#### Single-cell sequencing

{{< level 3 >}}


For this exercise we will be using some single-cell sequencing data. No biological expertise is required for this.

 
:::: {.callout-answer collapse="true"}

#### Exercise

Here is a brief code snippet to help you load the data and get started.

You have to follow the following steps:

* Data Loading and Preprocessing: Loading a single-cell sequencing dataset and normalizing features.

* XX

::: {.panel-tabset group="language"}


## Python


## R


:::

::::

:::::

 

::: {.callout-hint collapse=”true”}

Work in a group!

:::








### exercise_title {#sec-exr_title}

::::: {#ex-title .callout-exercise}

#### exercise_title

{{< level 3 >}}


For this exercise we will be using the data from `data/surveys.csv`.

 
:::: {.callout-answer collapse="true"}

#### subheading in answer

Description of answer.


::: {.panel-tabset group="language"}

## R


## Python

:::

::::

:::::

 

::: {.callout-hint collapse=”true”}

This is a hint

:::





## Summary

::: {.callout-tip}
#### Key Points

- Understand real-world scenarios where unsupervised learning is applied
- Identify situations where PCA and other dimensionality reduction techniques may not be effective
- Practical examples of data that you try unsupervised learning techniques on
:::



## Resources

- [Introduction to Statistical Learning in Python (ISLP) book](https://www.statlearning.com/)

- [Video lectures by the authors of the book Introduction to Statistical Learning in Python](https://www.youtube.com/playlist?list=PLoROMvodv4rNHU1-iPeDRH-J0cL-CrIda)

