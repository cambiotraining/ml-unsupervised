---
title: UMAP (Optional)
---

::: {.callout-tip}
#### Learning Objectives

- Brief introduction to UMAP
- Code to perform UMAP on data
:::



# UMAP Intuition

## What is UMAP?

_UMAP_ (Uniform Manifold Approximation and Projection) is another powerful unsupervised machine learning technique that helps visualize high-dimensional data in 2D or 3D. Think of it as a "smart cartographer" that creates a map of your complex data, revealing hidden patterns.

## The Core Idea: Preserve Both Local and Global Structure

### The Problem We are Solving
- Say you have cells with 20,000+ gene measurements
- You want to see which cells are similar to each other
- You want to understand both local neighborhoods AND global structure
- But 20,000 dimensions are impossible to visualize!

### The Solution
UMAP takes your high-dimensional data and creates a 2D map where:
- **Similar cells stay close together** (local structure preserved)
- **Different cells stay far apart** (global structure preserved)
- **Both local neighborhoods AND global relationships are maintained**

## How UMAP Works: The Intuition

### Step 1: Build a Graph of Relationships
```
Original Space (20,000+ genes):
Cell A: [Gene1=5, Gene2=10, Gene3=2, ... Gene20000=8]
Cell B: [Gene1=6, Gene2=11, Gene3=3, ... Gene20000=9]
Cell C: [Gene1=50, Gene2=100, Gene3=20, ... Gene20000=80]

UMAP creates a "friendship network":
- A and B are close friends (very similar)
- A and C are distant acquaintances (very different)
- B and C are also distant acquaintances
```

### Step 2: Create a 2D Map
```
UMAP creates a 2D layout where:
- Close friends (A and B) are placed near each other
- Distant acquaintances (A and C, B and C) are placed far apart
- The overall "social network" structure is preserved
```

## The "Manifold" Concept

### What is a Manifold?
Think of a manifold like the surface of a balloon:
- From far away, it looks like a simple sphere
- Up close, you can see it is actually a 2D surface curved in 3D space
- Your high-dimensional biological data might be "curved" in ways we can't see

### Why "Uniform"?
UMAP assumes your data is spread "uniformly" across this curved surface:
- No empty regions (uniform coverage)
- No overly crowded regions (uniform density)
- This helps create a balanced, interpretable map

## UMAP vs t-SNE: Key Differences

### What UMAP Does Better

**Preserves Global Structure**: 
   - t-SNE: Focuses mainly on local neighborhoods
   - UMAP: Maintains both local AND global relationships


<!--
### Visual Comparison
```
t-SNE Result:
○○○○○  ●●●●●  △△△△△
○○○○○  ●●●●●  △△△△△
○○○○○  ●●●●●  △△△△△
(Good local structure, but distances between clusters are meaningless)

UMAP Result:
○○○○○     ●●●●●     △△△△△
○○○○○     ●●●●●     △△△△△
○○○○○     ●●●●●     △△△△△
(Both local structure AND meaningful distances between clusters)
```
-->

## Key Parameters to Understand

### n_neighbors (Default: 15)
- Controls how many "friends" each cell considers
- **Low (5-10)**: Focus on very close neighbors, creates many small clusters
- **High (30-50)**: Consider more distant neighbors, creates fewer, larger clusters
- **Default (15)**: Usually works well for most datasets

### min_dist (Default: 0.1)
- Controls how tightly packed points can be in the final map
- **Low (0.01)**: Points can be very close together (tight clusters)
- **High (0.5)**: Points spread out more (looser clusters)
- **Default (0.1)**: Good balance between tightness and readability

### metric (Default: 'euclidean')
- How to measure distances between cells
- **'euclidean'**: Standard geometric distance (good for most data)
- **'cosine'**: Angle-based distance (good for normalized data)
- **'manhattan'**: City-block distance (good for sparse data)

<!--
## Real Biological Examples

### Single-Cell RNA Sequencing
```
Original data: 10,000 cells × 20,000 genes = 200 million data points

UMAP reveals:
- Clear cell type clusters (neurons, glia, immune cells)
- Developmental trajectories (cells transitioning between types)
- Meaningful distances between clusters (immune cells are far from neurons)
- Sub-clusters within major cell types (different neuron subtypes)
```

### Protein Expression Data
```
Original data: 1,000 cells × 50 proteins = 50,000 data points

UMAP reveals:
- Protein co-expression patterns
- Cell state transitions
- Treatment response groups
- Quality control issues (outliers, batch effects)
```

## Common Patterns in UMAP Plots

### Clear Clusters with Meaningful Distances
```
○○○○○     ●●●●●     △△△△△
○○○○○     ●●●●●     △△△△△
○○○○○     ●●●●●     △△△△△

This suggests: 3 distinct cell types with meaningful relationships
- Distance between ○ and ● clusters tells you how different they are
- Distance between ● and △ clusters tells you how different they are
```

### Developmental Trajectories
```
○○●●△△
○○●●△△
○○●●△△

This suggests: Cells transitioning from ○ → ● → △
- You can trace the developmental path
- Intermediate cells show mixed characteristics
```

### Hierarchical Structure
```
    ○○○○○
   ○○○○○○○
  ○○○○○○○○○
     ●●●●●
    ●●●●●●●
   ●●●●●●●●●
      △△△△△
     △△△△△△△
    △△△△△△△△△

This suggests: Major cell types (○, ●, △) with subtypes within each
```

-->

<!--
## When to Use UMAP

### Excellent for:
- **Exploratory data analysis**: "What's the overall structure of my data?"
- **Cell type identification**: "How many different cell types do I have?"
- **Trajectory analysis**: "How do cells transition between states?"
- **Quality control**: "Are there any weird outliers or batch effects?"
- **Comparative analysis**: "How do different conditions compare?"

### Good for:
- **Feature selection**: "Which genes/proteins are most important?"
- **Clustering validation**: "Do my clusters make sense?"
- **Hypothesis generation**: "These cells look similar, maybe they're related?"

### Not ideal for:
- **Exact quantitative comparisons**: "How similar are these cells exactly?"
- **Very small datasets**: "I only have 50 cells"
- **Highly noisy data**: "My data is very messy"

-->


## UMAP vs Other Methods

### UMAP vs PCA
- **PCA**: Linear method, preserves variance, good for linear relationships
- **UMAP**: Non-linear method, preserves local structure, good for complex relationships

### UMAP vs t-SNE
- **t-SNE**: Great for local structure, slower, harder to interpret distances
- **UMAP**: Good for both local and global structure, faster, more interpretable

<!--
### UMAP vs UMAP (Different Parameters)
- **Low n_neighbors**: More local detail, more clusters
- **High n_neighbors**: More global view, fewer clusters
- **Low min_dist**: Tighter clusters, harder to see individual points
- **High min_dist**: Looser clusters, easier to see individual points
-->

## Practical Tips

### 1. Start with Default Parameters
- UMAP's defaults work well for most biological data
- Don't over-optimize parameters initially

### 2. Try Different n_neighbors Values
- **5-10**: If you want to see fine-grained subpopulations
- **15-30**: For general exploration (recommended)
- **50+**: If you want to see only major cell types

### 3. Adjust min_dist for Readability
- **0.01-0.05**: If points are too spread out
- **0.1-0.3**: Default range (recommended)
- **0.5+**: If clusters are too tight

### 4. Use Multiple Runs
- UMAP has some randomness
- Run multiple times to ensure results are consistent
- Use `random_state` parameter for reproducible results

### 5. Validate with Biology
- Always check if UMAP results make biological sense
- Compare with known cell type markers
- Look for expected developmental trajectories

## Summary

UMAP is like a smart cartographer who:
1. **Studies your high-dimensional data** (20,000+ genes/proteins)
2. **Identifies both local neighborhoods AND global relationships**
3. **Creates a beautiful 2D map** that preserves both types of structure
4. **Reveals hidden patterns** you couldn't see before

The key insight: **UMAP preserves both local and global structure** - cells that are similar stay close together, while the distances between different cell types remain meaningful.

This makes UMAP perfect for biologists who want to understand the complete structure of their complex, high-dimensional data - from individual cell relationships to overall tissue organization!

<!--
## Next Steps

1. **Try the simple UMAP code** with your own data
2. **Experiment with different parameters** to see how they affect the results
3. **Compare UMAP with t-SNE** on the same dataset
4. **Validate results** with known biological markers
5. **Use UMAP for hypothesis generation** and further experiments
-->

_Remember_: UMAP is a tool for exploration and visualization, not a replacement for careful analysis!


## Hands-on with UMAP

The way to use _UMAP_ is similar to how we did tSNE.

```{python ch-umap-install}
#| warning: false
#| output: false

!pip install umap-learn
```

```{python ch-umap-simplecode}
#| warning: false

import numpy as np
import pandas as pd
from sklearn import datasets
from sklearn.preprocessing import StandardScaler
import umap
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid")  # nice simple plots

iris = datasets.load_iris()
X_iris = iris.data           # 150 samples, 4 features (sepal/petal lengths/widths)
y_iris = iris.target         # species labels (0,1,2)
labels_iris = iris.target_names

# create a data frame for easier viewing
df_iris_simple = pd.DataFrame(X_iris, columns = iris.feature_names)

df_iris_simple['species'] = iris.target
df_iris_simple['species_name'] = df_iris_simple['species'].map( {0:'setosa', 1:'versicolor', 2:'virginica'} )

# display basic information
print(df_iris_simple.head)

# scatter plots
plt.figure()
plt.scatter(X_iris[:,0], X_iris[:,1], c = iris.target, cmap='viridis')
plt.xlabel(iris.feature_names[0])
plt.ylabel(iris.feature_names[1])
plt.title('Sepal length vs. Sepal width')
plt.colorbar(label='species')
plt.show()

# Standardize features 
scaler = StandardScaler()
X_iris_scaled = scaler.fit_transform(X_iris)

# Run UMAP
umap_model = umap.UMAP(n_neighbors=15, min_dist=0.1, n_components=2, random_state=42)
embedding_iris = umap_model.fit_transform(X_iris_scaled)

# Put into DataFrame for plotting
df_iris = pd.DataFrame({
    "UMAP1": embedding_iris[:, 0],
    "UMAP2": embedding_iris[:, 1],
    "species": [labels_iris[i] for i in y_iris]
})

plt.figure()
sns.scatterplot(data=df_iris, x="UMAP1", y="UMAP2", hue="species", s=60)
plt.title("UMAP on Iris data")
plt.legend(loc="best")
plt.show()
```



* Quick tips:

- `n_neighbors` (default ~15): how many neighbors UMAP uses to learn local structure.

  Smaller => captures very local structure (more fragmentation), larger => more global structure.

- `min_dist` (default ~0.1): how tightly points are packed in the low-dimensional space.
  Smaller => tighter clusters; larger => more spread out.

- Always standardize or log-transform expression data before UMAP (depending on data type).

- Try different random_state values or parameters to see what changes.


* Exercises for learners:

1. Change `n_neighbors` to 5 and then to 50 and observe how the plot changes.

2. Change `min_dist` to 0.01 and 0.8 and observe clustering differences.

3. Replace synthetic data with a small real gene-expression matrix and try the pipeline:
   counts -> log1p -> StandardScaler -> UMAP.


```{python ch-umap-complexcode}
#| warning: false
#| echo: false
#| output: false


# -----------------------
# Example 2: Tiny synthetic gene-expression (cells × genes)
# -----------------------
# Create a small synthetic dataset with 3 cell types:
rng = np.random.RandomState(0)
n_cells = 120
n_genes = 30

# Simulate three cell populations with different mean expression profiles
cell_type_sizes = [40, 40, 40]
means = np.array([np.linspace(1, 3, n_genes),     # type A
                  np.linspace(2, 0.5, n_genes),   # type B
                  np.sin(np.linspace(0, 3, n_genes)) + 1])  # type C

X_counts = []
labels = []
for i, size in enumerate(cell_type_sizes):
    # simulate counts with Poisson around the mean (simple model)
    # add some noise per cell
    cells = rng.poisson(lam=np.maximum(0.1, means[i]), size=(size, n_genes))
    X_counts.append(cells)
    labels += [f"Type_{i+1}"] * size

X_counts = np.vstack(X_counts)  # shape (n_cells, n_genes)
labels = np.array(labels)

# Typical preprocessing for counts: log transform then standardize
X_log = np.log1p(X_counts)  # log(1 + counts)
X_log_scaled = StandardScaler().fit_transform(X_log)

# UMAP on gene expression
umap_g = umap.UMAP(n_neighbors=10, min_dist=0.3, n_components=2, random_state=1)
embedding_cells = umap_g.fit_transform(X_log_scaled)

df_cells = pd.DataFrame({
    "UMAP1": embedding_cells[:, 0],
    "UMAP2": embedding_cells[:, 1],
    "cell_type": labels
})

plt.figure(figsize=(7,5))
sns.scatterplot(data=df_cells, x="UMAP1", y="UMAP2", hue="cell_type", s=60)
plt.title("UMAP on tiny synthetic gene-expression data")
plt.legend(loc="best")
plt.tight_layout()
plt.show()
```


## Summary

::: {.callout-tip}
#### Key Points

- A brief introduction to UMAP
:::
